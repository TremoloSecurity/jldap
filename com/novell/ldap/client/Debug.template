// $Novell: /ldap/src/jldap/com/novell/ldap/client/Debug.template,v 1.2 2000/09/21 23:27:35 vtag Exp $

package com.novell.ldap.client;

import java.io.*;
import java.lang.reflect.*;
import java.util.Properties;
import java.util.StringTokenizer;

/**
 * The <code>Debug</code> class contains several useful debugging class (static)
 * methods. It cannot be instantiated.
 * Some methods give useful information, such as amount of memory used,
 * enabling instruction tracing, displaying object hierarchy, and dumping
 * the contents of a raw <code>byte</code> buffer.
 * <p>
 * <p>
 * Another type of debug supports two kinds of methods; those that inform
 * whether a debug option is set or not; and those that output the specified
 * string to the <code>System.err</code> stream when the associated debug value is set.
 * <p>
 * The Debug class checks in the object returned by <code>System.getProperties</code>
 * for the name <b>ldap.debug</b> which has the following valid values:
 * <ul>
 * <li><b><code>VMtraceInstructions</code></b> - Enables instruction trace</u>
 * <li><b><code>VMtraceMethodCalls</code></b> - Enables method call trace</u>
 * <li><b><code>trace</code></b> - Displays a string if the named property is set</u>
 * <li><b><code>dumpBuffer</code></b> - Displays raw buffer dumps</u>
 * <li><b><code>dumpObject</code></b> - Displays information about an object.
 * The following property values can limit the information displayed. If
 * dumpObject is selected, all those listed below are also selected</u>
 * <li><b><code>dumpObjectHierarchy</code></b> - Displays object hierarchy</u>
 * <li><b><code>dumpObjectConstructors</code></b> - Displays object constructors</u>
 * <li><b><code>dumpObjectFields</code></b> - Displays object fields</u>
 * <li><b><code>dumpObjectMethods</code></b> - Displays object methods</u>
 * </ul>
 * <p>
 * If multiple values are desired, they are separated by semicolon's, i.e.
 * <ul>
 * <code>java -Dldap.debug=serverprogress;echodebug TServer -tree junk</code>
 * </ul>
 * The values are case insensitive.  Invalid values are ignored.
 * <p>
 * The <code>ldap_debug</code> variable allows debug code to be excluded
 * from a compile by codeing something like the following:
 * <ul>
 * <li><code>if( Debug.LDAP_DEBUG) trace(trace.referrals, "Entering referral code");</code>
 * </ul>
 *
 * @author Steven F. Sonntag
 * @version $Id: Debug.template,v 1.2 2000/09/21 23:27:35 vtag Exp $
 */

public abstract class Debug {

    /**
     * The value for this variable is set during compile time
     *  TRUE = Debug build, FALSE = Release build
     */
    public static final boolean LDAP_DEBUG = @COMPILE_DEBUG@;

    /**
     * The string value used to enable all debug tracing.
     */
	public static final String all = "TraceAll";
    /**
     * The string value used to enable debug tracing of raw input.
     */
	public static final String rawInput = "RawInput";
    /**
     * The string value used to enable debug tracing of Raw Output.
     */
	public static final String rawOutput = "RawOutput";
    /**
     * The string value used to enable debug tracing of referral processing.
     */
	public static final String referrals = "Referrals";
    /**
     * The string value used to enable debug tracing of BER Encoding.
     */
	public static final String encoding = "Encoding";
    /**
     * The string value used to enable debug tracing of Ber Decoding.
     */
	public static final String decoding = "Decoding";
    /**
     * The string value used to enable debug tracing of LDAP Connections.
     */
	public static final String connections = "Connections";
    /**
     * The string value used to enable debug tracing of URL parsing.
     */
	public static final String urlParse = "UrlParse";
    /**
     * The string value used to enable debug display of buffer dumps.
     */
	public static final String buffer = "DumpBuffer";
    /**
     * The string value used to enable debug display of object dumps.
	 * Displays hierarchy, constructors, fields, and methods.
     */
	public static final String objects = "DumpObject";
    /**
     * The string value used to enable debug display of object hierarchy dumps.
     */
	public static final String objectHierarchy = "DumpObjectHierarchy";
    /**
     * The string value used to enable debug display of object constructor dumps.
     */
	public static final String objectConstructors = "DumpObjectConstructors";
    /**
     * The string value used to enable debug display of object field dumps.
     */
	public static final String objectFields = "DumpObjectFields";
    /**
     * The string value used to enable debug display of object methods dumps.
     */
	public static final String objectMethods = "DumpObjectMethods";
    /**
     * The string value used to enable VM instruction trace.
     */
	public static final String traceInstructions = "VMTraceInstructions";
    /**
     * The string value used to enable display VM method calls.
     */
	public static final String traceMethodCalls = "VMTraceMethodCalls";

    private static boolean dumpBuffer = false;
    private static boolean dumpObject = false;
    private static boolean dumpObjectHierarchy = false;
    private static boolean dumpObjectConstructors = false;
    private static boolean dumpObjectFields = false;
    private static boolean dumpObjectMethods = false;
    private static boolean VMtraceInstructions = false;
    private static boolean VMtraceMethodCalls = false;
    private static boolean traceAll = false;
    private static boolean traceRawInput = false;
    private static boolean traceRawOutput = false;
    private static boolean traceEncoding = false;
    private static boolean traceDecoding = false;
    private static boolean traceReferrals = false;
    private static boolean traceUrlParse = false;
    private static boolean traceConnections = false;
    private static Properties objprop = new Properties();
    private static Runtime run = Runtime.getRuntime(); // for trace, etc.


    private Debug()
    {
        return;
    }

    /*
     * toggle the state of a boolean variable
     */
    static private final boolean toggle( boolean b) {
        if( b )
            b = false;
        else
            b = true;
        return b;
    }

    /**
    * The constructor reads the system properties and set booleans that
    * control the various debug options.
    */
    static
    {
        if( LDAP_DEBUG) {
            Properties prop = System.getProperties();
            String sep = prop.getProperty("path.separator",";");
            StringTokenizer st =
                    new StringTokenizer(prop.getProperty("ldap.debug",""), sep);
            while( st.hasMoreTokens()) {
                String tn = new String( st.nextToken());
                /*
                 * Properties that turn on VM trace methods
                 */
                if( tn.equalsIgnoreCase("VMTraceInstructions")) {
                    VMtraceInstructions = true;                
                } else if( tn.equalsIgnoreCase("VMTraceMethodCalls")) {
                    VMtraceMethodCalls = true;                
                /*
                 * Properties that turn on object dump methods
                 */
                } else if( tn.equalsIgnoreCase(buffer)) {
                    dumpBuffer = true;
                } else if( tn.equalsIgnoreCase(objects)) {
                    dumpObject = true;
                    dumpObjectHierarchy = true;
                    dumpObjectConstructors = true;
                    dumpObjectFields = true;
                    dumpObjectMethods = true;
                } else if( tn.equalsIgnoreCase(objectHierarchy)) {
                    dumpObject = true;
                    dumpObjectHierarchy = true;
                } else if( tn.equalsIgnoreCase(objectConstructors)) {
                    dumpObject = true;
                    dumpObjectConstructors = true;
                } else if( tn.equalsIgnoreCase(objectFields)) {
                    dumpObject = true;
                    dumpObjectFields = true;
                } else if( tn.equalsIgnoreCase(objectMethods)) {
                    dumpObject = true;
                    dumpObjectMethods = true;
                /*
                 * Properties that turn on debug trace
                 */
                } else if( tn.equalsIgnoreCase(all)) {
                    traceRawInput = true;                
                    traceRawOutput = true;                
                    traceReferrals = true;                
                    traceUrlParse = true;                
                    traceEncoding = true;                
                    traceDecoding = true;                
                    traceConnections = true;                
                } else if( tn.equalsIgnoreCase(rawInput)) {
                    traceRawInput = toggle( traceRawInput);                
                } else if( tn.equalsIgnoreCase(rawOutput)) {
                    traceRawOutput = toggle( traceRawOutput);                
                } else if( tn.equalsIgnoreCase(referrals)) {
                    traceReferrals = toggle( traceReferrals);                
                } else if( tn.equalsIgnoreCase(urlParse)) {
                    traceUrlParse = toggle( traceUrlParse);                
                } else if( tn.equalsIgnoreCase(encoding)) {
                    traceEncoding = toggle( traceEncoding);                
                } else if( tn.equalsIgnoreCase(decoding)) {
                    traceDecoding = toggle( traceDecoding);                
                } else if( tn.equalsIgnoreCase(connections)) {
                    traceConnections = toggle( traceConnections);                
                }
            }
        }
    }

    /**
     * Returns <code>true</code> if <code>trace</code> is enabled
     * @param type The String value of the trace type to check.
     */
    public static final boolean trace( String type)
    {
        if( LDAP_DEBUG) {
            if( type.equalsIgnoreCase(all)) {
                return (    traceRawInput ||
                            traceRawOutput ||
                            traceReferrals ||
                            traceUrlParse  ||
                            traceEncoding  ||
                            traceDecoding  ||
                            traceConnections );
            } else if( type.equalsIgnoreCase(rawInput)) {
                return(traceRawInput);
            } else if( type.equalsIgnoreCase(rawOutput)) {
                return(traceRawOutput);
            } else if( type.equalsIgnoreCase(referrals)) {
                return(traceReferrals);
            } else if( type.equalsIgnoreCase(urlParse)) {
                return(traceUrlParse);
            } else if( type.equalsIgnoreCase(encoding)) {
                return(traceEncoding);
            } else if( type.equalsIgnoreCase(decoding)) {
                return(traceDecoding);
            } else if( type.equalsIgnoreCase(connections)) {
                return(traceConnections);
            }
            return false;
        } else {
            return false;
        }
    }
    /**
     * Turns on or off debug printing
     * @param type The String value of the trace type to enable or disable.
     * @param val The boolean value to enable or disable <code>trace</code>.
     */
    public static void setTrace( String type, boolean val)
    {
        if( LDAP_DEBUG) {
            if( type.equalsIgnoreCase(all)) {
                traceRawInput  = val;
                traceRawOutput = val;
                traceReferrals = val;
                traceUrlParse  = val;
                traceEncoding  = val;
                traceDecoding  = val;
                traceConnections = val;
            } else if( type.equalsIgnoreCase(rawInput)) {
                traceRawInput = val;
            } else if( type.equalsIgnoreCase(rawOutput)) {
                traceRawOutput = val;
            } else if( type.equalsIgnoreCase(referrals)) {
                traceReferrals = val;
            } else if( type.equalsIgnoreCase(urlParse)) {
                traceUrlParse = val;
            } else if( type.equalsIgnoreCase(encoding)) {
                traceEncoding = val;
            } else if( type.equalsIgnoreCase(decoding)) {
                traceDecoding = val;
            } else if( type.equalsIgnoreCase(connections)) {
                traceConnections = val;
            }
        }
        return;
    }
    /**
     * Displays the specified <code>String str</code> parameter to the
     * <code>System.err</code> stream if <code>trace</code> is enabled
     * @param type    The String value of the trace type to print.
     * @param str    A string to display.
     */
    public static final void trace( String type, String str)
    {
        if( LDAP_DEBUG) {
            boolean printit = false;
            if( type.equalsIgnoreCase(all)) {
                printit =   traceRawInput  ||
                            traceRawOutput ||
                            traceReferrals ||
                            traceUrlParse  ||
                            traceEncoding  ||
                            traceDecoding  ||
                            traceConnections;
            } else if( type.equalsIgnoreCase(rawInput)) {
                printit = traceRawInput;
            } else if( type.equalsIgnoreCase(rawOutput)) {
                printit = traceRawOutput;
            } else if( type.equalsIgnoreCase(referrals)) {
                printit = traceReferrals;
            } else if( type.equalsIgnoreCase(urlParse)) {
                printit = traceUrlParse;
            } else if( type.equalsIgnoreCase(encoding)) {
                printit = traceEncoding;
            } else if( type.equalsIgnoreCase(decoding)) {
                printit = traceDecoding;
            } else if( type.equalsIgnoreCase(connections)) {
                printit = traceConnections;
            }
            if( printit)
            if( str == null) {
                System.err.println("  \nprintDebug: Cannot print NULL string");
            } else {
                System.err.println( str);
            }
        }
        return;
    }

    /**
     * Returns <code>true</code> if <code>VMtraceInstructions</code> is enabled
     */
    public static final boolean VMtraceInstructions()
    {
        return VMtraceInstructions;
    }
    /**
    *    Displays trace of each instruction executed in the virtual machine
    * @param onOff    A boolean that when set to true enables instruction
    * tracing and when false disables instruction tracing.
    */
    public static void VMtraceInstructions( boolean onOff)
    {
        if( LDAP_DEBUG) {
            if( VMtraceInstructions)
                run.traceInstructions( onOff);
        }
        return;
    }

    /**
     * Returns <code>true</code> if <code>VMtraceMethodCalls</code> is enabled
     */
    public static final boolean VMtraceMethodCalls()
    {
        return VMtraceMethodCalls;
    }
    /**
    *    Displays trace of each methods called 
    * @param onOff    A boolean that when set to true enables method call
    * tracing and when false disables instruction tracing.
    */
    public static void VMtraceMethodCalls( boolean onOff)
    {
        if( LDAP_DEBUG) {
            if( VMtraceMethodCalls)
                run.traceMethodCalls( onOff);
        }
        return;
    }

    /**
    *    Returns the total memory available in the virtual machine
    */
    public static long totalMemory( )
    {
        if( LDAP_DEBUG) {
            return run.totalMemory( );
        }
        return 0;
    }

    /**
    *    Returns the free memory available in the virtual machine
    */
    public static long freeMemory( )
    {
        if( LDAP_DEBUG) {
            return run.freeMemory( );
        }
        return 0;
    }

    /**
     * Returns <code>true</code> if <code>dumpObect</code> is enabled
     */
    public static final boolean dumpObject()
    {
        return dumpObject;
    }
    /**
     * Turns on or off debug dumpObject
     * @param val The boolean value to enable or disable <code>dumpObject</code>.
     */
    public static void setDumpObject( boolean val)
    {
        if( LDAP_DEBUG) {
            dumpObject = val;
            dumpObject = true;
            dumpObjectHierarchy = true;
            dumpObjectConstructors = true;
            dumpObjectFields = true;
            dumpObjectMethods = true;
        }
        return;
    }
    /**
     * Returns <code>true</code> if <code>dumpObjectHierarchy</code> is enabled
     */
    public static final boolean dumpObjectHierarchy()
    {
            return dumpObjectHierarchy;
    }
    /**
     * Turns on or off debug dumpObjectHierarchy
     * @param val The boolean value to enable or disable <code>dumpObjectHierarchy</code>.
     */
    public static void setDumpObjectHierarchy( boolean val)
    {
        if( LDAP_DEBUG) {
            dumpObject = val;
            dumpObjectHierarchy = val;
        }
        return;
    }

    /**
     * Returns <code>true</code> if <code>dumpObectConstructors</code> is enabled
     */
    public static final boolean dumpObjectConstructors()
    {
        return dumpObjectConstructors;
    }
    /**
     * Turns on or off debug dumpObjectConstructors
     * @param val The boolean value to enable or disable <code>dumpObjectConstructors</code>.
     */
    public static void setDumpObjectConstructors( boolean val)
    {
        if( LDAP_DEBUG) {
            dumpObject = val;
            dumpObjectConstructors = val;
        }
        return;
    }
    /**
     * Returns <code>true</code> if <code>dumpObjectFields</code> is enabled
     */
    public static final boolean dumpObjectFields()
    {
        return dumpObjectFields;
    }
    /**
     * Turns on or off debug dumpObjectFields
     * @param val The boolean value to enable or disable <code>dumpObjectFields</code>.
     */
    public static void setDumpObjectFields( boolean val)
    {
        if( LDAP_DEBUG) {
            dumpObject = val;
            dumpObjectFields = val;
        }
        return;
    }
    /**
     * Returns <code>true</code> if <code>dumpObectMethods</code> is enabled
     */
    public static final boolean dumpObjectMethods()
    {
        return dumpObjectMethods;
    }
    /**
     * Turns on or off debug dumpObjectMethods
     * @param val The boolean value to enable or disable <code>dumpObjectMethods</code>.
     */
    public static void setDumpObjectMethods( boolean val)
    {
        if( LDAP_DEBUG) {
            dumpObject = val;
            dumpObjectMethods = val;
        }
        return;
    }

    /**
    * Displays information about an object.  The amount of information displayed
    * is controlled by various environment variables or set methods. These are:
    * <li><b><code>dumpObject</code></b> - Displays all information about an object.
    * <li><b><code>dumpObjectHierarchy</code></b> - Displays object hierarchy</u>
    * <li><b><code>dumpObjectConstructors</code></b> - Displays object constructors</u>
    * <li><b><code>dumpObjectFields</code></b> - Displays object fields</u>
    * <li><b><code>dumpObjectMethods</code></b> - Displays object methods</u>
    * </ul>
    * <p>
    * Multiple environment values are separated by semicolon's, i.e.
    * <ul>
    * <code>java -Doil.debug=serverprogress;echodebug TServer -tree junk</code>
    * </ul>
    * @param obj The object to dump
    */
    public static final void dumpObject( Object obj)
    {
        if( LDAP_DEBUG) {
            int level = 2;

            if( obj == null) {
                System.err.println("  \ndumpObject: No class information obtainable for NULL class");
                return;
            }
            if( ! dumpObject)
                return;
            // Print object name
            Class theClass = obj.getClass();
            if( theClass == null)
            {
                System.err.println("\ndumpObject: No class information obtainable for "
                    + obj.toString());
                return;
            }
            Class oldClass = (Class)objprop.put( theClass.getName(), theClass);
            if( oldClass != null)
                return;        // We have already reported on this class
            System.err.println("\nV------------------------------------------------------------------------------V");
            System.err.println("Object of class  " + theClass.getName());
            // Print toString info
            System.err.println("\n  " + obj.toString() + "\n");

            if( dumpObjectHierarchy) {
                // Print getDeclaredClasses info
                Class Dclasses[] = theClass.getDeclaredClasses();
                System.err.println("  Classes returned by getDeclaredClasses is "
                    + Dclasses.length);
                for( int i = 1; i <= Dclasses.length; i++)
                {
                    System.err.println("      " + i + " " + Dclasses[i-1].getName());
                }
                // Print getDeclaringClass info
                Class DCclass = theClass.getDeclaringClass();
                if( DCclass == null)
                {
                    System.err.println("  Class returned by getDeclaringClass is null");
                } else {
                    System.err.println("  Class returned by getDeclaringClass is "
                        + DCclass.getName());
                }
                // Print Signers of class
                Object gsigners[] = theClass.getSigners();
                if( gsigners == null)
                {
                    System.err.println("  Signers returned by getSigners is null");
                }
                else
                {
                    System.err.println("  Signers returned by getSigners is "
                        + gsigners.length);
                    for( int i = 1; i <= gsigners.length; i++)
                    {
                        System.err.println("      " + i + " "
                            +  gsigners[i-1].toString());
                    }
                }
                // Print getClasses info
                Class classes[] = theClass.getClasses();
                System.err.println("  Classes returned by getClasses is "
                    + classes.length);
                for( int i = 1; i <= classes.length; i++)
                {
                    System.err.println("      " + i + " " + classes[i-1].getName());
                }
                // Print object class hierarchy
                Class superClass = theClass;
                System.err.println("\n  Class Hierarchy");
                dumpClasses( superClass, level);
            }

            if( dumpObjectConstructors) {
                // Print getGetConstructors
                Constructor constructors[] = theClass.getConstructors();
                System.err.println("  Constructors returned by getConstructors is "
                    + constructors.length);
                for( int i = 1; i <= constructors.length; i++)
                {
                    System.err.println("      " + i + " "
                        + constructors[i-1].getName()
                        + ": " + constructors[i-1].toString());
                }
                // Print getGetDeclaredConstructors
                Constructor dconstructors[] = theClass.getDeclaredConstructors();
                System.err.println(
                    "  Declared Constructors returned by getDeclaredConstructors is "
                    + dconstructors.length);
                for( int i = 1; i <= dconstructors.length; i++)
                {
                    System.err.println("      " + i + " "
                        + dconstructors[i-1].getName() + ": "
                        + dconstructors[i-1].toString());
                }
            }
            if( dumpObjectFields) {
                // Print getFields
                Field gfields[] = theClass.getFields();
                System.err.println("  Fields returned by getFields is "
                    + gfields.length);
                for( int i = 1; i <= gfields.length; i++)
                {
                    Class fieldClass;
                    System.err.println("      " + i + " " + gfields[i-1].getName()
                        + ": " + gfields[i-1].toString());
                    fieldClass = gfields[i-1].getType();
                    if( ! fieldClass.isPrimitive())
                        dumpClasses( fieldClass, level+2);
                }
                // Print getDeclared Fields
                Field dfields[] = theClass.getDeclaredFields();
                System.err.println("  Fields returned by getDeclaredFields is "
                    + dfields.length);
                for( int i = 1; i <= dfields.length; i++)
                {
                    Class fieldClass;
                    System.err.println("      " + i + " " + dfields[i-1].getName()
                        + ": " + dfields[i-1].toString());
                    fieldClass = dfields[i-1].getType();
                    if( ! fieldClass.isPrimitive())
                        dumpClasses( fieldClass, level+2);
                }
            }

            if( dumpObjectMethods) {
                // Print getMethods
                try {
                    Method gmethods[] = theClass.getMethods();
                    System.err.println("  Methods returned by getMethods is "
                        + gmethods.length);
                    for( int i = 1; i <= gmethods.length; i++)
                    {
                        System.err.println("      " + i + " " + gmethods[i-1].getName()
                            + ": " + gmethods[i-1].toString());
                    }
                } catch( NoClassDefFoundError e) {
                    System.err.println("  getMethods returned NoClassDefFoundError Exception " + e.toString());
                }
                // Print getDeclared Methods
                try {
                    Method dmethods[] = theClass.getDeclaredMethods();
                    System.err.println("  Methods returned by getDeclaredMethods is "
                        + dmethods.length);
                    for( int i = 1; i <= dmethods.length; i++)
                    {
                        System.err.println("      " + i + " " + dmethods[i-1].getName()
                            + ": " + dmethods[i-1].toString());
                    }
                } catch( NoClassDefFoundError e) {
                    System.err.println("  getDeclaredMethods returned NoClassDefFoundError Exception " + e.toString());
                }
            }
            System.err.println("\n^------------------------------------------------------------------------------^");
        }
        return;
    }

    // Print Interface heirarchy
    static private void dumpInterfaces( Class obj, int level)
    {
        if( LDAP_DEBUG) {
            Class sinterfaces[] = obj.getInterfaces();
            for( int i = 1; i <= sinterfaces.length; i++)
            {
                for( int j = 0; j < level; j++)
                    System.err.print("  ");
                System.err.println(sinterfaces[i-1].toString());
                dumpInterfaces( sinterfaces[i-1], level+1);
            }
        }
        return;
    }

    // Print Class heirarchy
    static private void dumpClasses( Class obj, int level)
    {
        if( LDAP_DEBUG) {
            do
            {
                for( int j = 0; j < level; j++)
                     System.err.print("  ");
                System.err.println( obj.toString());
                dumpInterfaces(  obj, level+1);
            } while( ( obj =  obj.getSuperclass()) != null);
        }
        return;
    }

    /**
     * Returns <code>true</code> if <code>dumpBuffer</code> is enabled
     */
    public static final boolean dumpBuffer()
    {
        return dumpBuffer;
    }
    /**
     * Turns on or off debug dumpBuffer
     * @param val The boolean value to enable or disable <code>dumpBuffer</code>.
     */
    public static void setDumpBuffer( boolean val)
    {
        if( LDAP_DEBUG) {
            dumpBuffer = val;
        }
        return;
    }

    /**
    *    Dumps a the specified portion of the byte array, as hexidecmal bytes
    *   and also intrepreted as ASCII.
    *    @param msg The title to display before the buffer dump
    *   @param inBuffer The byte arrary buffer to dump
    *   @param fileOffset The address displayed is offset by this amount
    *   @param length The number of bytes to display
    *
    */
    static public void dumpBuffer( String msg, byte[] inBuffer, int fileOffset, int length)
    {
        if( LDAP_DEBUG) {
            int byteCnt = 0;    
            byte[] tstLine = new byte[16];    // Place to store the test line
            boolean haveTstLine = false;    // Test line stored
            boolean matchTstLine = false;    // Current line matches test line
            boolean matchLastLine = false;    // Previous line matches test line

            if( !dumpBuffer)
                return;
            System.err.println( msg);
            while( byteCnt < length) {
                if( (byteCnt + 16) >= length - 1) { // Always print the last line
                    if( matchLastLine) {
                        System.err.println("******");
                    }
                    matchTstLine = false;
                } else {                            // Not the last line
                    if( haveTstLine) {
                        matchTstLine = false;        // Assume we don't have a match
                        for( int i = 0; i < 16; i++) {
                            if(tstLine[i] != inBuffer[byteCnt + i]) {
                                if( matchLastLine) {    // print ***** for skips
                                    System.err.println("******");
                                }
                                haveTstLine = false;
                                matchLastLine = false;
                                matchTstLine = false;
                                break;
                            }
                        }
                        matchLastLine = true;        // Make sure prev line set for next loop
                        matchTstLine = true;        // Assume we have a match
                    }
                    if( ! haveTstLine) {            // Get a test line if needed
                        for( int i = 0; i < 16; i++) {
                            tstLine[i] = inBuffer[byteCnt + i];
                        }
                        haveTstLine = true;
                        matchTstLine = false;
                        matchLastLine = false;
                    }
                }
                if( matchTstLine) {
                    byteCnt += 16;
                    continue;
                }
                dumpLine( inBuffer, byteCnt, length, fileOffset);
                byteCnt += 16;
                continue;
            }
        }
        return;
    } // dumpBuffer

    private static void dumpLine( byte[] inBuffer, int offset, int length, int addrOffset)
    {
        if( LDAP_DEBUG) {
            byte DOT = 0x2e;                // ascii period
            byte SP = 0x20;                // ascii space
            String hexDigits;
            int byteCnt = offset;    
            int itemCnt;

            String address = Integer.toHexString( offset + addrOffset);
            while( address.length() < 6) {
                address = "0" + address;
            }
            System.err.print( address + "    ");
            for( itemCnt = 0; itemCnt < 16; itemCnt++) {
                hexDigits = Integer.toHexString( inBuffer[byteCnt]);
                byteCnt++;
                if( hexDigits.length() > 2) {
                    hexDigits = hexDigits.substring( hexDigits.length()-2, hexDigits.length());
                }
                if( hexDigits.length() == 2) {
                    System.err.print( hexDigits + " ");
                } else {
                    System.err.print( "0" + hexDigits + " ");
                }
                if( itemCnt == 7) {
                    System.err.print(" ");
                }
                // Check for last byte
                if( byteCnt == length) {
                    itemCnt++;            // Make sure count of items is correct
                    break;
                }
            }
            // Copy the characters previously printed.  We will now print them
            // in character format.  We copy the array as we are going to modify
            // the non printable characters and add a count at the beginning.
            byte[] b = new byte[itemCnt + 2];
            b[0] = 0;
            b[1] = (byte)itemCnt;
            for( int i = 0; i < itemCnt; i++) {
                // Prepare for printing character - make sure doesn't intrepret
                // as Unicode
                if( inBuffer[offset+i] < SP) {
                    b[i+2] = DOT;
                } else {
                    b[i+2] = inBuffer[offset+i];
                }
            }
            try {
                DataInputStream dataStream =
                        new DataInputStream(
                        new ByteArrayInputStream(b));
                System.err.println(dataStream.readUTF());
            } catch( Exception e) {
                System.err.println(e.toString());
                System.err.println(e.getMessage());
                System.exit(1);
            }        
        }
        return;
    }
} // Debug
