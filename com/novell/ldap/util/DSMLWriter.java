/* Generated by Together */

package com.novell.ldap.ldif_dsml;

import com.novell.ldap.*;

import java.io.*;
import java.util.Iterator;

public class DSMLWriter implements LDAPWriter {

    public final static LDAPRequest currentChange = null;
    private OutputStreamWriter out = null;
    private int state = NEW_BATCH;
    private static final int NEW_BATCH = 0;
    private static final int REQUEST_BATCH = 1;
    private static final int RESPONSE_BATCH = 2;
    private static final int SEARCH_TAG = 3;
    private boolean indent = false;
    private String tabString = "    ";

    private static final String BATCH_REQUEST_START =
            "<batchRequest xmlns=\"urn:oasis:names:tc:DSML:2.0:core\">";
    private static final String BATCH_RESPONSE_START =
            "<batchResponse xmlns=\"urn:oasis:names:tc:DSML:2.0:core\">";


    public DSMLWriter(String file) throws FileNotFoundException {
        this( new FileOutputStream(file, true));
    }

    public DSMLWriter(OutputStream stream){
        out = new OutputStreamWriter(stream);
    }

    public void writeOperation(PrintStream ps) {
        this.out = new OutputStreamWriter(ps);
    }

    public void finish() throws IOException {
        newLine(0);
        if (state == REQUEST_BATCH){
            out.write("</batchRequest>");
        } else if (state == RESPONSE_BATCH){
            out.write("</batchResponse>");
        }
        newLine(0);
        out.flush();
        out.close();
    }

    public void writeOperation(LDAPMessage messageToWrite) throws IOException,
            LDAPLocalException {
        //check state and write batch tags if neccessary
        if ((messageToWrite instanceof LDAPResponse) ||
            (messageToWrite instanceof LDAPSearchResult) ||
            (messageToWrite instanceof LDAPSearchResultReference)){
            checkState(true);
        } else {//must be a request
            checkState(false);
        }

        //write the message tags
        switch (messageToWrite.getType()) {
            //requests:
            case LDAPMessage.BIND_REQUEST:
            case LDAPMessage.UNBIND_REQUEST:
            case LDAPMessage.SEARCH_REQUEST:
            case LDAPMessage.BIND_RESPONSE:
            case LDAPMessage.MODIFY_REQUEST:
            case LDAPMessage.ADD_REQUEST:
            case LDAPMessage.DEL_REQUEST:
            case LDAPMessage.MODIFY_RDN_REQUEST:
            case LDAPMessage.COMPARE_REQUEST:
            case LDAPMessage.ABANDON_REQUEST:
            case LDAPMessage.EXTENDED_REQUEST:
                throw new java.lang.UnsupportedOperationException(
                        "Writing of this message is not supported");

            //Responses:
            case LDAPMessage.SEARCH_RESPONSE:
                if (state != SEARCH_TAG){
                    newLine(1);
                    out.write("<searchResponse>");
                    state = SEARCH_TAG;
                }
                writeSearchResponse((LDAPSearchResult) messageToWrite);
                break;
            case LDAPMessage.SEARCH_RESULT:  //final search done message (or standard referral)
                if (state != SEARCH_TAG){
                    newLine(1);
                    out.write("<searchResponse>");
                }
                newLine(2);
                out.write("<searchResultDone>");
                    writeResult((LDAPResponse)messageToWrite, 3);
                newLine(2);
                out.write("</searchResultDone>");

                newLine(1);
                out.write("</searchResponse>");
                state = REQUEST_BATCH;
                break;

            case LDAPMessage.MODIFY_RESPONSE:
                newLine(1);
                out.write("<modifyResponse>");
                writeResult((LDAPResponse)messageToWrite, 2);
                newLine(1);
                out.write("</modifyResponse>");
                break;

            case LDAPMessage.ADD_RESPONSE:
                newLine(1);
                out.write("<addResponse>");
                writeResult((LDAPResponse)messageToWrite, 2);
                newLine(1);
                out.write("</addResponse>");
                break;

            case LDAPMessage.DEL_RESPONSE:
                newLine(1);
                out.write("<delResponse>");
                writeResult((LDAPResponse)messageToWrite, 2);
                newLine(1);
                out.write("</delResponse>");
                break;

            case LDAPMessage.MODIFY_RDN_RESPONSE:
                newLine(1);
                out.write("<modDNResponse>");
                writeResult((LDAPResponse)messageToWrite, 2);
                newLine(1);
                out.write("</modDNResponse>");
                break;
            case LDAPMessage.COMPARE_RESPONSE:
                newLine(1);
                out.write("<compareResponse>");
                writeResult((LDAPResponse)messageToWrite, 2);
                newLine(1);
                out.write("</compareResponse>");
                break;
            case LDAPMessage.SEARCH_RESULT_REFERENCE:
                if (state != SEARCH_TAG){
                    newLine(1);
                    out.write("<searchResponse>");
                    state = SEARCH_TAG;
                }
                writeSearchResultReference(
                        (LDAPSearchResultReference) messageToWrite);
                break;
            case LDAPMessage.EXTENDED_RESPONSE:
                newLine(1);
                out.write("<errorResponse type=\"other\"><message>ExtendedRequest not supported</message></errorResponse>");
                break;
        }
    }

    private void writeResult(LDAPResponse result, int indent) throws IOException {
        /* controls: */
        //LDAPControl[] controls = result.getControls();

        /* referal: */

        /* result code: */
        newLine(indent);
        out.write("<resultCode code=\"");
        out.write(new Integer(result.getResultCode()).toString());
        out.write("\" descr=\"");
        out.write(LDAPException.resultCodeToString(result.getResultCode()));
        out.write( "\"/>");

        /* Server Message: */
        String temp = result.getErrorMessage();
        if (temp != null && temp.length() > 0){
            newLine(indent);
            out.write("<errorMessage>");
            out.write(temp);
            out.write("</errorMessage>");
        }

        /* MatchedDN*/
        temp = result.getMatchedDN();
        if (temp != null && temp.length() > 0){
            newLine(indent);
            out.write("<matchedDN>");
            out.write(temp);
            out.write("</matchedDN>");
        }
        return;
    }

    private void writeSearchResultReference(LDAPSearchResultReference ref)
            throws IOException
    {
        String[] refs = ref.getReferrals();
        newLine(2);
        out.write("<searchResultReference>");
        for(int i=0; i< refs.length; i++){
            newLine(3);
            out.write("<ref>");
            out.write(refs[i]);
            out.write("</ref>");
        }
        newLine(2);
        out.write("</searchResultReference>");
    }
    private void writeSearchResponse(LDAPSearchResult result)
            throws IOException
    {
        LDAPEntry entry = result.getEntry();
        newLine(2);
        out.write("<searchResultEntry dn=\"");
        out.write(entry.getDN());
        out.write("\">");
        LDAPAttributeSet set = entry.getAttributeSet();
        Iterator i = set.iterator();
        while (i.hasNext()){
            writeAttribute( (LDAPAttribute) i.next());
        }
        newLine(2);
        out.write("</searchResultEntry>");

        return;
    }

    private void writeAttribute(LDAPAttribute attr) throws IOException {
        newLine(3);
        out.write("<attr name=\"");
        out.write(attr.getName());
        out.write("\">");
        String values[] = attr.getStringValueArray();
        for(int i=0; i<values.length; i++){
            newLine(4);
            out.write("<value>");
            out.write(values[i]);
            out.write("</value>");
        }
        newLine(3);
        out.write("</attr>");
        return;
    }

    /**
     * Tests the current state with a new message that is either a response or
     * request.  If the state is NEW_BATCH, check_state will print an
     * appropriate batch tag.
     *
     * @param isResponse    Indicates if the message to be written is a response
     *                      or not.
     * @throws IOException
     * @throws LDAPLocalException
     */
    private void checkState(boolean isResponse)
            throws IOException, LDAPLocalException
    {
        if (state == NEW_BATCH) {
            if (isResponse) {
                out.write(BATCH_RESPONSE_START);
                state = RESPONSE_BATCH;
            }
            else{
                out.write(BATCH_REQUEST_START);
                state = REQUEST_BATCH;
            }
        }
        else if ((state == REQUEST_BATCH) && (isResponse)) {
            throw new LDAPLocalException(
                "Attempted insertion of a response message in a request batch",
                LDAPException.ENCODING_ERROR);
        } else if (state == RESPONSE_BATCH && (!isResponse)) {
                throw new LDAPLocalException(
                "Attempted insertion of a request message in a response batch",
                LDAPException.ENCODING_ERROR);
        }
        return;
    }

    private void newLine(int indentTabs) throws IOException {
        if (!indent)
            return;
        out.write("\n");
        for (int i=0; i< indentTabs; i++){
            out.write(tabString);
        }
        out.flush();
        return;
    }

    public void useIndent( boolean useIndent ){
        this.indent = useIndent;
    }

    public void setIndent( int spaces){
        StringBuffer temp = new StringBuffer();
        for (int i=0; i< spaces; i++){
            temp.append(' ');
        }
        this.tabString = temp.toString();
    }
    /*
    private void writeRequest(LDAPMessage request) throws IOException
    {


    } */


}
